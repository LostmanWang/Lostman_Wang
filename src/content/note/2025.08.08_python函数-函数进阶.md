---
title: Python函数-函数进阶
description: 函数进阶
publishDate: 2025-08-08T14:52
---
## 一、函数参数传递

* 在 CPython 中，所有参数传递都是“对象指针（内存地址）的按值拷贝”——官方称为 call-by-object-reference。

### 1、内存模型总览

```
调用者栈帧                被调函数栈帧
┌────────┐               ┌────────┐
│ 变量 a │──→ 对象 1001  ←──│ 形参 x │
└────────┘               └────────┘
```

* `a` 和 `x` 各自保存 **同一份对象** 地址 1001。
* 对 **对象本身** 的修改，取决于 1001 指向的对象 **是否可变**。

### 2、不可变类型：重新赋值 = 新建对象

```python
def inc(n):
    n += 1        # 新建 int 对象，x 指向新地址
    print(id(n))  # 与外部不同
a = 10
inc(a)
print(a)          # 10
```

#### 字节码关键指令

```
LOAD_FAST 0 (n)
LOAD_CONST 1 (1)
INPLACE_ADD      # 新建 int，赋值回 n
```

* 形参 `n` 指向 新对象，外部 `a` 仍指向旧对象 → 值不变。

### 3、可变类型：原地修改 = 外部可见

```python
def grow(lst):
    lst.append(1)   # 修改现有列表对象
a = [10]
grow(a)
print(a)            # [10, 1]
```

* 1001 指向 可变列表对象，原地改内部数组 → 外部同步看到。

### 4、重新赋值 vs 原地修改对照表

| 场景         | 代码            | 结果   | 原因      |
| ---------- | ------------- | ---- | ------- |
| 不可变 + 重新赋值 | `x = x + 1`   | 外部不变 | 新建对象    |
| 可变 + 原地修改  | `x.append(1)` | 外部变化 | 同一对象    |
| 可变 + 重新赋值  | `x = [99]`    | 外部不变 | 形参指向新对象 |

### 5、深拷贝 vs 浅拷贝补充

* **浅拷贝**（`copy.copy`）仅复制容器外壳，子对象仍共享地址。
* **深拷贝**（`copy.deepcopy`）递归复制所有子对象 → 彻底独立。

## 二、函数返回值传递
