---
title: Python函数-函数进阶
description: 函数进阶
publishDate: 2025-08-08T14:52
---
## 一、函数参数传递

* 在 CPython 中，所有参数传递都是“对象指针（内存地址）的按值拷贝”——官方称为 call-by-object-reference。

### 1、内存模型总览

```
调用者栈帧                被调函数栈帧
┌────────┐               ┌────────┐
│ 变量 a │──→ 对象 1001  ←──│ 形参 x │
└────────┘               └────────┘
```

* `a` 和 `x` 各自保存 **同一份对象** 地址 1001。
* 对 **对象本身** 的修改，取决于 1001 指向的对象 **是否可变**。

### 2、不可变类型：重新赋值 = 新建对象

```python
def inc(n):
    n += 1        # 新建 int 对象，x 指向新地址
    print(id(n))  # 与外部不同
a = 10
inc(a)
print(a)          # 10
```

#### 字节码关键指令

```
LOAD_FAST 0 (n)
LOAD_CONST 1 (1)
INPLACE_ADD      # 新建 int，赋值回 n
```

* 形参 `n` 指向 新对象，外部 `a` 仍指向旧对象 → 值不变。

### 3、可变类型：原地修改 = 外部可见

```python
def grow(lst):
    lst.append(1)   # 修改现有列表对象
a = [10]
grow(a)
print(a)            # [10, 1]
```

* 1001 指向 可变列表对象，原地改内部数组 → 外部同步看到。

### 4、重新赋值 vs 原地修改对照表

| 场景         | 代码            | 结果   | 原因      |
| ---------- | ------------- | ---- | ------- |
| 不可变 + 重新赋值 | `x = x + 1`   | 外部不变 | 新建对象    |
| 可变 + 原地修改  | `x.append(1)` | 外部变化 | 同一对象    |
| 可变 + 重新赋值  | `x = [99]`    | 外部不变 | 形参指向新对象 |

## 二、函数返回值传递

* 在 CPython 中，“函数返回值” 本质上只干一件事：把 对象在堆上的内存地址（PyObject）复制给调用者。

| 场景           | 修改/重新赋值 | 调用者是否可见 | 原因       |
| ------------ | ------- | ------- | -------- |
| 返回 **不可变对象** | 重新绑定    | ❌       | 新对象，地址已变 |
| 返回 **可变对象**  | 原地修改    | ✅       | 同一地址，内容变 |
| 返回 **可变对象**  | 重新绑定    | ❌       | 变量指向新地址  |

### 1、底层机制：返回值 = 地址按值拷贝

```
调用者栈帧                被调函数栈帧
┌────────┐               ┌────────┐
│ 变量 r │──→ 对象 1001  ←──│ return │
└────────┘               └────────┘
```

* `return obj` 把 **对象 1001 的地址** 复制给调用者变量 `r`。
* 无论对象可变或不可变，拷贝的都是 **地址值本身**。

### 2、不可变类型：重新绑定 = 新建对象

```python
def inc():
    x = 10
    x += 1          # 新建 int 对象
    return x        # 返回新地址

a = inc()
print(a)            # 11
```

#### 字节码关键指令

```
LOAD_CONST 1 (10)
STORE_FAST 0 (x)
LOAD_FAST 0
LOAD_CONST 2 (1)
BINARY_ADD        # 新建 int 对象
RETURN_VALUE      # 返回新地址
```

* 原对象 10 不变；调用者拿到 新对象 11 的地址。

### 3、可变类型：原地修改 = 外部可见

```python
def make_list():
    lst = [1, 2]
    lst.append(3)   # 原地修改
    return lst      # 返回同一地址

b = make_list()
print(b)            # [1, 2, 3]
```

* 地址始终为 1001；内容被修改 → 调用者 同步看到。

### 4、重新绑定 vs 原地修改对照

| 操作       | 代码              | 结果   | 解释        |
| -------- | --------------- | ---- | --------- |
| **重新绑定** | `lst = [99]`    | 外部不变 | 新地址，原地址弃用 |
| **原地修改** | `lst.append(9)` | 外部变化 | 同一地址，内容变  |

## 三、
