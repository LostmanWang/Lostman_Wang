---
title: Python数据类型-基础数据类型-序列类型 --- list, tuple, range
description: 序列类型 --- list, tuple, range
publishDate: 2025-07-29T15:54
---
## 一、通用序列操作

* 大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。collections.abc.Sequence ABC被提供用来更容易地在自定义序列类型上正确地实现这些操作。
* 此表按优先级升序列出了序列操作。在表格中，s 和 t 是具有相同类型的序列，n, i, j 和 k 是整数而 x 是任何满足 s 所规定的类型和值限制的任意对象。
* in 和 not in 操作具有与比较操作相同的优先级。+ (拼接) 和 * (重复) 操作具有与对应数值运算相同的优先级。

![](/assets/images/2025-07-29_16-24.png)

### 1、index(self, value, start=0, stop=sys.maxsize) → int

#### 1.1、在序列的指定切片 [start:stop) 范围内，从左到右查找第一次出现的元素 value，并返回其下标。若未找到，抛出 ValueError。

#### 1.2、参数

* value（必选）：要查找的元素，与序列元素做 == 比较。
* start（可选，默认为 0）：切片起始下标（包含）。
* stop（可选，默认为 sys.maxsize）：切片结束下标（不包含）。

#### 1.3、返回值

* 找到时返回 int 类型的下标（相对于原序列，而非切片）。
* 未找到时抛出 ValueError: <value> is not in sequence。

#### 1.4、边界/细节

* 支持负索引；start 或 stop 越界会被自动截断。
* 若序列中允许重复元素，只返回 最左侧 的第一次出现。
* 时间复杂度平均为 O(n)，因为需要线性扫描。

```python
>>> from collections.abc import Sequence
>>> t = ('a', 'b', 'c', 'b')
>>> Sequence.index(t, 'b')          # 等价于 t.index('b')
1
>>> t.index('b', 2)                 # 从下标 2 开始找
3
>>> t.index('x')
Traceback (most recent call last):
  ...
ValueError: 'x' is not in tuple
```

### 2、count(self, value) → int

#### 2.1、统计序列中 所有位置（无切片参数）与 value 相等的元素出现次数。

#### 2.2、参数

* value（必选）：要计数的元素，使用 == 比较。

#### 2.3、返回值

* int：出现次数；若一次也没有返回 0。
* 不会抛出异常，即使元素不存在。

#### 2.4、边界/细节

* 同样使用线性扫描，时间复杂度 O(n)。
* 对于可变序列（如 list），统计的是调用时刻的快照。
* 字符串、元组、列表、bytes 等内部实现均遵循同一语义。

```python
>>> seq = [1, 2, 1, 3, 1]
>>> seq.count(1)
3
>>> seq.count(99)
0
>>> 'banana'.count('na')
2
```

### 3、len()获取列表长度

```python
# 获取列表长度 
print(len([1, 2, 3, 4])) 

# 输出结果 
4
```

### 4、max()获取列表值最大的元素

```python
# max
a = [1, 2, 3]
print(max(a))

# 输出解雇
3
```

### 5、min()获取列表值最小的元素

## 二、不可变序列类型

* 不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对hash() 内置函数的支持。
* 这种支持允许不可变类型，例如tuple 实例被用作dict 键，以及存储在set 和frozenset 实例中。
* 尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致TypeError。

## 三、可变序列类型

* 以下表格中的操作是在可变序列类型上定义的。collections.abc.MutableSequence ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。
* 表格中的 s 是可变序列类型的实例，t 是任意可迭代对象，而 x 是符合对 s 所规定类型与值限制的任何对象 (例如，bytearray 仅接受满足 0 <= x <= 255 值限制的整数)。

![](/assets/images/2025-07-29_19-38.png)

### 1、append(self, value) → None

* 作用：在序列尾部追加单个元素。
* 参数：value – 待追加的对象。
* 返回值：None（就地修改）。
* 复杂度：均摊 O(1)。

```python
>>> lst = [1, 2]
>>> lst.append(3)
>>> lst
[1, 2, 3]
```

### 2、clear(self) → None

* 作用：删除序列中所有元素，使其长度变为 0。
* 参数：无。
* 返回值：None。

```python
>>> lst = [1, 2, 3]
>>> lst.clear()
>>> lst
[]
```

### 3、copy(self) → MutableSequence

* 作用：返回序列的浅拷贝（新对象，元素本身不复制）。
* 参数：无。
* 返回值：与原序列同类型的空壳副本。

```python
>>> lst = [[1], [2]]
>>> cp = lst.copy()
>>> cp[0].append(9)   # 修改元素，原列表受影响
>>> lst
[[1, 9], [2]]
```

### 4、extend(self, iterable) → None

* 作用：将可迭代对象中的所有元素依次追加到尾部。
* 参数：iterable – 任意可迭代对象（列表、元组、生成器等）。
* 返回值：None。
* 复杂度：O(k)，k 为 iterable 长度。

```python
>>> lst = [1, 2]
>>> lst.extend((3, 4))
>>> lst
[1, 2, 3, 4]
```

### 5、insert(self, index, value) → None

* 作用：在指定下标前插入元素；负索引也可。
* 参数：index – 插入位置；value – 待插入元素。
* 返回值：None。
* 复杂度：O(n)。

```python
>>> lst = ['a', 'c']
>>> lst.insert(1, 'b')
>>> lst
['a', 'b', 'c']
```

### 6、pop(self, index=-1) → element

* 作用：移除并返回指定下标的元素；默认移除最后一个。
* 参数：index – 可选，默认为 -1。
* 返回值：被弹出的元素。
* 异常：IndexError（空序列或越界）。

```python
>>> lst = [10, 20, 30]
>>> lst.pop()
30
>>> lst.pop(0)
10
>>> lst
[20]
```

### 7、remove(self, value) → None

* 作用：删除第一个与 value 相等的元素。
* 参数：value – 待移除的值（按 == 比较）。
* 返回值：None。
* 异常：ValueError（元素不存在）。

```python
>>> lst = [1, 2, 3, 2]
>>> lst.remove(2)
>>> lst
[1, 3, 2]
```

### 8、reverse(self) → None

* 作用：就地反转序列顺序。
* 参数：无。
* 返回值：None。
* 复杂度：O(n)。

```python
>>> lst = [1, 2, 3]
>>> lst.reverse()
>>> lst
[3, 2, 1]
```

## 四、列表 list

* 列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）

### 1、构造方法：

#### 1.1、字面量构造（空列表或初值列表）

```python
q = []                    # 空队列
q = [1, 2, 3]             # 带初始元素
```

* 最轻量，**O(1)** 创建；
* 只负责“容器”，**不提供线程安全或性能优化**。

#### 1.2、构造函数 `list(iterable)`

```python
q = list(range(5))        # [0, 1, 2, 3, 4]
q = list("abc")           # ['a', 'b', 'c']
```

* 任何可迭代对象 → 列表；
  复杂度 **O(n)**，n 为去重后元素个数。

#### 1.3、列表推导式 / 生成器表达式

```python
# 列表推导式：一次性构造
q = [x**2 for x in range(10) if x % 2 == 0]

# 生成器表达式：惰性迭代，先转 list
q = list(x for x in range(1000000) if x % 997 == 0)
```

* 语法灵活，可直接生成“队列初始数据”。

#### 1.4、从其他容器转换

* **tuple**：list((1,2,3))	元组 → 列表
* **set**：list({1,2,3})	集合 → 列表（无序）
* **dict**：list({'a':1,'b':2})	键视图 → 列表
* **文件对象**：list(open('file.txt'))	每行一个元素

#### 1.5、`*` 展开构造

```python
# 合并多个可迭代对象
q = [*range(3), *"abc", *[7, 8]]   # [0, 1, 2, 'a', 'b', 'c', 7, 8]
```

* Python 3.5+ 的解包语法，用于“一次性拼接”。

#### 1.6、双端队列（deque）—— 官方推荐高性能队列

```python
from collections import deque
dq = deque()                 # 空双端队列
dq = deque([1, 2, 3])        # 带初始数据
dq = deque(maxlen=1000)      # 环形缓冲区，满时自动丢弃最旧元素
```

* 生产环境 推荐 collections.deque，因为它在两端插入/删除都是 O(1)，而 list.insert(0, x) 是 O(n)。
* 完全兼容 list 的迭代、切片读取；
* 额外方法：appendleft, popleft, extendleft, rotate, maxlen。

#### 1.7、线程安全队列（queue 模块）

```python
import queue
q = queue.Queue()            # FIFO
q = queue.Queue(maxsize=100) # 阻塞/非阻塞模式
```

* 若需要在 **多线程** 中当真正队列，使用 `queue.Queue`/`LifoQueue`/`PriorityQueue`，内部用锁保护
* 与 list 接口不同：通过 put, get, task_done 管理。

#### 1.8、性能对比速览

![](/assets/images/2025-08-01_15-22.png)

* 临时/单线程：q = \[] 或 q = list(iterable)。
* 高频两端操作：用 collections.deque(iterable)。
* 多线程安全：用 queue.Queue(maxsize)。

### 2、list.sort(*, key=None, reverse=False)

#### 2.1、作用

* 原地重排：调用后原列表顺序被永久改变。
* 稳定排序：排序前后，相等元素的相对顺序不变。
* 多字段排序：可一次指定多个键，实现多级排序（例如先按年龄再按姓名）。

#### 2.2、参数

![](/assets/images/2025-07-30_14-49.png)

#### 2.3、返回值

* 始终返回 None。
* 因为排序是原地操作，所以 不返回新列表；若写 new_list = old_list.sort()，会得到 None，这是常见错误。

```python
# 基础升序
nums = [3, 1, 4, 1, 5]
nums.sort()
print(nums)          # [1, 1, 3, 4, 5]

# 降序
nums.sort(reverse=True)
print(nums)          # [5, 4, 3, 1, 1]

# 按字符串长度排序
words = ['python', 'is', 'awesome']
words.sort(key=len)
print(words)         # ['is', 'python', 'awesome']

# 多字段排序：先按成绩降序，再按姓名升序
students = [('Alice', 90), ('Bob', 85), ('Alice', 95)]
students.sort(key=lambda s: (-s[1], s[0]))
print(students)      # [('Alice', 95), ('Alice', 90), ('Bob', 85)]
```

### 3、公共功能

#### 3.1、运算符 +

* 相加，两个列表相加获取生成一个新的列表。

```python
# + 运算
a = [1] + [2, 3, ] + [4, 5]
print(a)

b = [1, 2] + ["3", "4"]
print(b)

# 输出结果
[1, 2, 3, 4, 5]
[1, 2, '3', '4']
```

#### 3.2、运算符 *

* 相乘，列表*整型 将列表中的元素再创建N份并生成一个新的列表。

```python
# * 运算
a = [1, 2] * 3
print(a)

# 输出结果
[1, 2, 1, 2, 1, 2]
```

#### 3.3、索引（下标）取值

```python
# 读
user_list = ["范德彪","刘华强",'尼古拉斯赵四']
print( user_list[0] )
print( user_list[2] )
print( user_list[3] ) # 报错

# 改
user_list = ["范德彪","刘华强",'尼古拉斯赵四']
user_list[0] = "武沛齐"
print(user_list) # ["武沛齐","刘华强",'尼古拉斯赵四']

# 删
user_list = ["范德彪","刘华强",'尼古拉斯赵四']
del user_list[1]

user_list.remove("刘华强")
ele = user_list.pop(1)
```

:::note

超出索引范围会报错。

由于字符串是不可变类型，所以他只有索引读的功能，而列表可以进行 读、改、删

:::

#### 3.4、切片取值

* 和字符串一样，列表也可以切片
* 使用语法：列表\[start : end : step]，获取列表中在 [start, end) 范围的子列表
* 注意范围 [start, end) 包含 start，不包含 end
* step 是步长，设为 n，则每隔 n 个元素获取一次

```python
# 读
user_list = ["范德彪","刘华强",'尼古拉斯赵四']
print( user_list[0:2] ) # ["范德彪","刘华强"]
print( user_list[1:] )
print( user_list[:-1] )
```

#### 3.5、切片赋值

```python
# 切片赋值
a = ["1", "2", "3"]
print(a)
a[:] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]  # 切片获取所有元素，并重新赋值
print(a)

a[2:4] = [33, 44]
print(a)

a[2:4] = []  # 相当于去掉第 3、4 个元素
print(a)

a[:] = []  # 将 a 赋值为空列表
print(a)


# 输出结果
['1', '2', '3']
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
[1, 2, 33, 44, 5, 6, 7, 8, 9, 0]
[1, 2, 5, 6, 7, 8, 9, 0]
[]
```

:::note

赋值的值也必须是列表，否则会报错  TypeError: can only assign an iterable 

:::

#### 3.6、关键字 in

* 通过关键字 in 检查列表中是否包含指定元素，返回 bool 值
* not in 则是取反

```python
# in、not in
a = [1, 2, True, {"name": "小菠萝"}, ["how", "hi"]]

print(1 in a)
print(3 in a)
print({"name": "小菠萝"} in a)
print(False not in a)


# 输出结果
True
False
True
True
```

## 五、元组tuple

* 元组是不可变序列，通常用于储存异构数据的多项集（例如由enumerate() 内置函数所产生的二元组）。
* 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到set 或dict 的实例）。

### 1、构造方法：

`class tuple([iterable ])`

可以用多种方式构建元组：

* 使用一对圆括号来表示空元组: ()
* 使用一个后缀的逗号来表示单元组: a, 或 (a,)
* 使用以逗号分隔的多个项: a, b, c or (a, b, c)
* 使用内置的tuple(): tuple() 或 tuple(iterable)

### 2、公共功能

#### 2.1、运算符 +

* 使用运算符 + 连接多个元组

```python
# +
tup1 = (1,)
tup2 = (2, 3)
print(tup1 + tup2)


# 输出结果
(1, 2, 3)
```

#### 2.2、运算符 *

* 使用运算符 * 将元组的元素重复

```python
# *
tup = (1, 2)
print(tup * 2)


# 输出结果
(1, 2, 1, 2)
```

#### 2.3、索引（下标）取值

```python
# 索引
tup = [1, 2, 3, 4, 5]
print(tup[0])
print(tup[-1])
print(tup[2])


# 输出结果
1
5
3
```

#### 2.4、切片取值

* 和列表一样，元组也可以切片
* 使用语法：元组\[start : end : step]，获取元组中在 [start, end) 范围的子元组
* 注意范围 [start, end) 包含 start，不包含 end
* step 是步长，设为 n，则每隔 n 个元素获取一次

```python
# 切片
tup = [1, 2, 3, 4, 5, 6, 7, 8]
print(tup[:])  # 取全部元素
print(tup[0:])  # 取全部元素
print(tup[2:5])  # 取第 3 个元素到第 5 个元素
print(tup[::-1])  # 倒序取所有元素
print(tup[-3:-1])  # 取倒数第 3 个元素到倒数第 2 个元素


# 输出结果
[1, 2, 3, 4, 5, 6, 7, 8]
[1, 2, 3, 4, 5, 6, 7, 8]
[3, 4, 5]
[8, 7, 6, 5, 4, 3, 2, 1]
[6, 7]
```

#### 2.5、关键字 in

* 通过关键字 in 检查元组中是否包含指定元素，返回 bool 值
* not in 则是取反

```python
# in
tup = (1, 2, 3)
print(1 in tup)
print(22 not in tup)


# 输出结果
True
True
```

## 六、range 对象

* range 类型表示不可变的数字序列通常用于在 for 循环中循环指定的次数

### 1、构造方法：

#### `1.1、class range(stop)`

* 表示区间 [0, stop) 内的整数序列
* 该区间从 0 开始、到 stop 结束，不包含 stop

#### `1.2、class range(start, stop[, step ])`

* 表示区间 [start, stop) 内的整数序列
* 该区间从 start 开始、到 end 结束，不包含 end
* step 是步进，默认是 1

### 2、range 的优势

* 相比常规list 或tuple 的优势在于一个range 对象总是占用固定数量的（较小）内存，不论

  其所表示的范围有多大（因为它只保存了 start, stop 和 step 值，并会根据需要计算具体单项或子范围

  的值）。

### 3、range 的特性

* range 对象实现了 collections.abc.Sequence ，提供了包括 index、索引、切片等特性

```python
r = range(0, 20, 2)
print(r)
print(list(r))

# in
print(10 in r)
print(11 not in r)

# index
print(r.index(6))

# 切片
print(r[2])
print(r[-1])


# 输出结果
range(0, 20, 2)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
True
True
3
4
18
```

### 4、==、!= 操作

* 使用 == 和 != 检测 range 对象是否相等是将其作为序列来比较。也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。（请注意比较结果相等的两个 range 对象可能会具有不同的start, stop和step 属性，例如 range(0) == range(2, 1, 3) 而 range(0, 3, 2) == range(0, 4, 2)。）

```python
r1 = range(0, 4, 2)
r2 = range(0, 3, 2)
print(r1 == r2)


# 输出结果
True
```

### 5、循环遍历 range

```python
for item in range(3):
    print(item)


# 输出结果
0
1
2
```
