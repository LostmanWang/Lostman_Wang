---
title: Python函数-函数高级
description: 函数高级
publishDate: 2025-08-13T10:23
---
## 一、嵌套函数（nested function / inner function）

### 1、定义

* 在一个 **def 语句的内部**再写一个 **def 语句**，里面的函数就叫**嵌套函数**（inner / nested function），外面的函数叫**外层函数**（outer / enclosing function）。

```python
def outer(x):
    y = 10
    def inner(z):      # ← 嵌套函数
        return x + y + z
    return inner
```

### 2、语法规则速览

* 嵌套深度不限，可以 `f1` 里套`f2`，`f2`里再套 `f3` …
* 内层函数名**仅在外层函数局部作用域可见**；外层无法直接调用 inner()。
* 内层函数可以**被返回、塞进容器、当作参数传递**，从而在外层函数返回后仍然存活——这就是**闭包**。

### 3、生命周期（LEGB 视角）

#### 3.1、编译阶段

Python 看到 `def inner` 时，会为 `inner` 生成一个**代码对象** `inner.__code__`，并记录：

* `co_freevars`：在内层用到、却定义在外层的**自由变量**名（free variables）。
* `co_cellvars`：外层定义、被内层引用的**被捕获变量**名。

#### 3.2、运行阶段

* 外层函数被调用 → 创建局部变量 → 遇到 `return inner` → 返回一个**函数对象**，其 `__closure__` 属性指向若干 **cell** 对象，每个 cell 保存一个自由变量的当前值。

#### 3.3、外层函数返回后

* 栈帧销毁，但 cell 仍被内层函数引用 → 变量继续存活 → **闭包诞生**。

### 4、作用域与名字查找（LEGB）

`Local → Enclosing → Global → Builtin`

* **读**外层变量：直接可读。
* **写**外层变量：默认会创建同名局部变量，除非显式声明 `nonlocal`。
* **写**全局变量：需 `global` 声明。

```python
def outer():
    cnt = 0
    def inner(step=1):
        nonlocal cnt      # 不写则 UnboundLocalError
        cnt += step
        return cnt
    return inner

counter = outer()
print(counter(), counter())   # 1 2
```

### 5、闭包（closure）——嵌套函数 + 自由变量

* 满足三个条件：1. 函数嵌套；2. 内层引用外层变量；3. 外层返回内层。
* 底层结构：

```python
>>> counter.__code__.co_freevars
('cnt',)
>>> counter.__closure__[0].cell_contents
2
```

## 二、函数闭包（function closure）

### 1、定义

* **闭包 = 函数对象 + 外层作用域的“现场快照”**。
* 即使外层函数已经执行完毕，闭包仍然能访问那些被捕获的变量。

### 2、产生的三个硬条件（面试常问）

1. 必须有**函数嵌套**；
2. 内层函数**引用了外层非全局变量**（free variable）；
3. 外层函数**把内层函数返回**（或作为参数、塞进容器）。

```python
def outer(x):
    y = 10
    def inner(z):
        return x + y + z   # 引用了 x、y
    return inner           # 返回内层函数

f = outer(2)               # 闭包诞生
print(f(3))                # 2 + 10 + 3 = 15
```

### 3、底层原理

#### 3.1、编译阶段

* `inner.__code__.co_freevars` → `('x', 'y')` 声明需要外层的哪些变量。
* `outer.__code__.co_cellvars` → `('x', 'y')` 声明要提供给内层做闭包。

#### 3.2、运行阶段

* 每产生一个自由变量，就创建一个 cell 对象，位于 `frame.f_localsplus`。
* 外层返回后，栈帧销毁，但 cell 仍被 `inner.__closure__` 引用，值继续存活。

#### 3.3、查看现场

```python
>>> f.__closure__
(<cell at 0x...: int object at 0x...>,
 <cell at 0x...: int object at 0x...>)
>>> f.__closure__[0].cell_contents
2
>>> f.__closure__[1].cell_contents
10
```

### 4、常见陷阱与对策

#### 4.1、循环变量闭包陷阱

* 原因：所有回调捕获**同一个 cell**，循环结束后变量定格在最终值。

```python
funcs = [lambda: i for i in range(3)]
print([f() for f in funcs])   # [2, 2, 2]
```

* 修复：用默认参数把值“冻”在定义时

```python
funcs = [lambda i=i: i for i in range(3)]
```

#### 4.2、延迟绑定（late binding）

* 类似 4.1，常见于 GUI、回调注册。
* 解决：再加一层闭包或用 `functools.partial`。

#### 4.3、nonlocal 忘记写

* 在内层赋值会默认创建局部变量，导致 `UnboundLocalError`。

```python
def counter():
    cnt = 0
    def inc():
        nonlocal cnt   # 必须声明
        cnt += 1
        return cnt
    return inc
```

### 5、实用模式

#### 5.1、函数工厂（配置固化）

```python
def power(n):
    def f(x):
        return x ** n
    return f

square = power(2)
cube   = power(3)
```

#### 5.2、私有状态（轻量级对象）

```python
def make_bank(initial=0):
    balance = initial
    def atm(action, amount=0):
        nonlocal balance
        if action == 'deposit':
            balance += amount
        elif action == 'withdraw':
            if amount <= balance:
                balance -= amount
                return amount
            else:
                raise ValueError('NSF')
        return balance
    return atm

my_acct = make_bank(100)
my_acct('deposit', 50)   # 150
my_acct('withdraw', 30)  # 120
```

#### 5.3、装饰器骨架（高阶 + 闭包）

```python
import time
from functools import wraps

def timeit(fn):
    @wraps(fn)
    def wrapper(*args, **kw):
        t0 = time.perf_counter()
        ret = fn(*args, **kw)
        print('cost:', time.perf_counter() - t0)
        return ret
    return wrapper
```

## 三、函数装饰器（function decorator）

### 1、定义

* **“用一个可调用对象（函数或类）去** **包装（wrap）** **另一个可调用对象，从而** **无侵入地增强其行为**”的设计模式。

### 2、语法糖与手工展开

```python
@decorator
def original(x):
    return x + 1

# 等价于
def original(x):
    return x + 1
original = decorator(original)
```

* 执行时机：**模块导入时**立即执行一次，返回的新函数被绑定到原名字。
* 装饰器本身可以是：函数、类、lambda、partial 对象，只要最终返回一个 callable。

### 3、无参装饰器模板（最常用）

```python
from functools import wraps

def log(func):
    @wraps(func)                 # 保留原函数元数据
    def wrapper(*args, **kw):
        print('call', func.__name__)
        ret = func(*args, **kw)
        print('done')
        return ret
    return wrapper
```

#### 关键点

* 嵌套函数形成闭包，保存原函数引用。
* `@wraps` 复制 `__name__/__doc__/__annotations__`，否则调试信息会丢失。

### 4、带参装饰器（三层嵌套）

```python
def repeat(n):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kw):
            for _ in range(n):
                ret = func(*args, **kw)
            return ret
        return wrapper
    return decorator

@repeat(3)
def hello():
    print('hi')
```

* 执行顺序：`repeat(3)` → 返回 **装饰器** → `@decorator` 再装饰 `hello`。

### 5、叠加装饰器（顺序从近到远）

```python
@d2
@d1
def f(): ...
# 等价于 f = d2(d1(f))
```

### 6、类装饰器（可维护状态）

```python
class count_calls:
    def __init__(self, func):
        self.func = func
        self.n = 0

    def __call__(self, *args, **kw):
        self.n += 1
        print('call #', self.n)
        return self.func(*args, **kw)

@count_calls
def add(a, b):
    return a + b
```

* 优点：可保存状态（如计数、缓存）；缺点：需要实现 `__call__`。

### 7、典型实战套路

#### 7.1、计时器

```python
import time, functools

def timeit(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        t0 = time.perf_counter()
        ret = func(*args, **kw)
        print('cost', time.perf_counter() - t0)
        return ret
    return wrapper
```

#### 7.2、重试（backoff）

```python
import time, functools

def retry(times=3, delay=1):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            for i in range(times):
                try:
                    return func(*args, **kw)
                except Exception as e:
                    if i == times - 1:
                        raise e
                    time.sleep(delay)
        return wrapper
    return decorator
```

#### 7.3、缓存（LRU）

```python
@functools.lru_cache(maxsize=128)
def fib(n):
    return n if n < 2 else fib(n-1) + fib(n-2)
```

#### 7.4、Flask 路由

```python
@app.route('/hello')
def hello():
    return 'hello'
```

### 8、常见陷阱与调试技巧

| 坑                | 描述                                | 解决                                     |
| ---------------- | --------------------------------- | -------------------------------------- |
| **元数据丢失**        | `wrapper.__name__` 变成 `'wrapper'` | 用 `@functools.wraps(func)`             |
| **执行时机**         | 装饰器在 import 时执行，可能过早              | 用工厂函数或 `if __name__ == '__main__':` 控制 |
| **位置参数/关键字参数维护** | 忘记 `*args, **kw` 导致签名不匹配          | 用 `inspect.signature` 检查               |
| **叠加顺序**         | 先 `@log` 再 `@cache` 会每次打印         | 按需调换顺序                                 |
