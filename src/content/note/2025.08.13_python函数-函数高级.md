---
title: Python函数-函数高级
description: 函数高级
publishDate: 2025-08-13T10:23
---
## 一、嵌套函数

### 1、定义

* 在一个 **def 语句的内部**再写一个 **def 语句**，里面的函数就叫**嵌套函数**（inner / nested function），外面的函数叫**外层函数**（outer / enclosing function）。

```python
def outer(x):
    y = 10
    def inner(z):      # ← 嵌套函数
        return x + y + z
    return inner
```

### 2、语法规则速览

* 嵌套深度不限，可以 `f1` 里套`f2`，`f2`里再套 `f3` …
* 内层函数名**仅在外层函数局部作用域可见**；外层无法直接调用 inner()。
* 内层函数可以**被返回、塞进容器、当作参数传递**，从而在外层函数返回后仍然存活——这就是**闭包**。

### 3、生命周期（LEGB 视角）

#### 3.1、编译阶段

Python 看到 `def inner` 时，会为 `inner` 生成一个**代码对象** `inner.__code__`，并记录：

* `co_freevars`：在内层用到、却定义在外层的**自由变量**名（free variables）。
* `co_cellvars`：外层定义、被内层引用的**被捕获变量**名。

#### 3.2、运行阶段

* 外层函数被调用 → 创建局部变量 → 遇到 `return inner` → 返回一个**函数对象**，其 `__closure__` 属性指向若干 **cell** 对象，每个 cell 保存一个自由变量的当前值。

#### 3.3、外层函数返回后

* 栈帧销毁，但 cell 仍被内层函数引用 → 变量继续存活 → **闭包诞生**。

### 4、作用域与名字查找（LEGB）

`Local → Enclosing → Global → Builtin`

* **读**外层变量：直接可读。
* **写**外层变量：默认会创建同名局部变量，除非显式声明 `nonlocal`。
* **写**全局变量：需 `global` 声明。

```python
def outer():
    cnt = 0
    def inner(step=1):
        nonlocal cnt      # 不写则 UnboundLocalError
        cnt += step
        return cnt
    return inner

counter = outer()
print(counter(), counter())   # 1 2
```

### 5、闭包（closure）——嵌套函数 + 自由变量

* 满足三个条件：1. 函数嵌套；2. 内层引用外层变量；3. 外层返回内层。
* 底层结构：

```python
>>> counter.__code__.co_freevars
('cnt',)
>>> counter.__closure__[0].cell_contents
2
```

### 6、嵌套函数的典型用途

#### 6.1、函数工厂（配置固化）

```python
def power(n):
    def f(x):
        return x ** n
    return f

square = power(2)
```

#### 6.2、数据隐藏 / 私有变量（轻量级替代类）

```python
def make_stack():
    items = []
    def push(x): items.append(x)
    def pop():   return items.pop()
    return push, pop
```

#### 6.3、装饰器（decorator）

```python
def timer(fn):
    import time
    def wrapper(*args, **kw):
        t0 = time.perf_counter()
        ret = fn(*args, **kw)
        print(time.perf_counter() - t0)
        return ret
    return wrapper
```

#### 6.4、回调函数 / 惰性求值

* 把局部状态封装在闭包里，避免全局变量。

### 7、常见错误与面试陷阱

#### 7.1、循环变量闭包陷阱

```python
funcs = [lambda: i for i in range(3)]
print([f() for f in funcs])   # [2,2,2]
```

* 修复：用默认参数捕获值

```python
funcs = [lambda i=i: i for i in range(3)]
```

#### 7.2、忘记 `nonlocal` 导致创建同名局部变量

```python
def outer():
    x = 1
    def inner():
        x = x + 1   # UnboundLocalError
    inner()
```

#### 7.3、把可变对象当默认参数

```python
def outer(data=[]):   # 列表只在定义时创建一次
    def inner(x):
        data.append(x)
        return data
    return inner
```

#### 7.4、多层嵌套时 `nonlocal` 只向上最近一层查找，找不到就 SyntaxError。
