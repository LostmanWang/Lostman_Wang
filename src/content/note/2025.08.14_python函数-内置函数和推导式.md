---
title: Python函数-内置函数和推导式
description: 匿名函数、生成器、内置函数和推导式
publishDate: 2025-08-14T11:26
---
## 一、匿名函数

### 1、定义

* `lambda 参数列表: 单表达式` 会即时返回一个**函数对象**，没有名字，通常作为一次性、短小逻辑的“即用即弃”函数。

### 2、基本语法

| 位置  | 写法举例                              | 说明                  |
| --- | --------------------------------- | ------------------- |
| 无参  | `lambda: 42`                      | 直接返回 42             |
| 单参  | `lambda x: x*2`                   | 输入乘以 2              |
| 多参  | `lambda x, y, z=10: x+y+z`        | 支持默认参数              |
| 可变参 | `lambda *a, **kw: len(a)+len(kw)` | 支持 \*args、\**kwargs |

#### 注意：

* **只能有一个表达式**，不能出现赋值、for、if-else 语句（三元表达式可以）。
* 返回值就是表达式的值，无需`return`。

### 3、作用域规则（与 def 完全一致）

* 遵循 LEGB；
* 同样形成闭包：

```python
# 这里 i=i 把循环变量冻结到默认参数，避免“延迟绑定陷阱”。
adders = [lambda x, i=i: x + i for i in range(3)]
print([f(10) for f in adders])   # [10, 11, 12]
```

### 4、与 `def` 的对比

| 维度  | lambda           | def        |
| --- | ---------------- | ---------- |
| 名称  | 匿名               | 必须显式命名     |
| 主体  | 单表达式             | 多语句块       |
| 结果  | 隐式 return        | 可显式 return |
| 可读性 | 极短逻辑             | 长逻辑更清晰     |
| 调试  | 栈跟踪显示 `<lambda>` | 显示函数名      |
| 注解  | 无法直接写注解          | 支持完整的函数签名  |

### 5、常见误区

#### 5.1、“lambda 比 def 快”

* 执行速度几乎一样；lambda 只是省去了栈帧名字绑定。

#### 5.2、循环变量陷阱

```python
fs = [lambda: i for i in range(3)]
print([f() for f in fs])   # [2, 2, 2]

# 解决：用默认参数或改用 def。
```

#### 5.3、试图写多行

```python
lambda x: y = x*2; return y   # SyntaxError

# 长逻辑请用 def。
```

### 6、进阶技巧

* 立即调用：`(lambda x: x**2)(5)`
* 与高阶函数搭配：`map`、`filter`、`sorted` 的`key` 参数
* 柯里化：

```python
from functools import partial
mul = lambda x, y: x * y
double = partial(mul, 2)
```

### 7、典型场景

#### 7.1、`sorted` 的 key 函数

```python
sorted(students, key=lambda s: s.score, reverse=True)
```

#### 7.2、GUI 回调 / CLI 框架

```python
button.clicked.connect(lambda: print('clicked'))
```

#### 7.3、小脚本中的过滤

```python
evens = list(filter(lambda n: n % 2 == 0, range(10)))
```

## 二、三元运算符

### 1、语法结构

```python
value_if_true if condition else value_if_false
```

* `condition`：一个布尔表达式，其结果为 True 或 False。
* `value_if_true`：如果 `condition` 为 True，则返回这个值。
* `value_if_false`：如果 `condition` 为 False，则返回这个值。

### 2、基本用法

```python
x = 10
y = 20

# 使用三元运算符
result = x if x > y else y
print(result)  # 输出 20
```

* 在这个例子中，`x > y` 是条件。因为 `x` 不大于 `y`，所以条件为 `False`，返回 `y`。

### 3、更复杂的表达式

```python
a = 5
b = 10

# 使用三元运算符嵌套
result = "Both are equal" if a == b else "a is greater" if a > b else "b is greater"
print(result)  # 输出 "b is greater"
```

### 4、与传统 `if-else` 的对比

#### 4.1、传统 `if-else`

```python
x = 10
y = 20

if x > y:
    result = x
else:
    result = y

print(result)  # 输出 20
```

#### 4.2、三元运算符

```python
x = 10
y = 20

result = x if x > y else y
print(result)  # 输出 20
```

* 三元运算符在表达简单逻辑时更加简洁，但当逻辑复杂时，建议使用传统的 `if-else` 结构，以提高代码的可读性。

### 5、注意事项

1. 可读性：虽然三元运算符很简洁，但嵌套使用时可能会降低代码的可读性。尽量避免过度嵌套。
2. 短路行为：三元运算符具有短路行为。如果条件为 True，则不会计算 `value_if_false`；如果条件为 False，则不会计算 `value_if_true`。
3. 类型一致性：虽然 Python 允许 `value_if_true` 和 `value_if_false` 是不同类型，但为了代码的可读性和一致性，建议它们是相同类型。

### 6、实际应用场景

#### 6.1、设置默认值

```python
user_input = input("Enter a number: ")
number = int(user_input) if user_input.isdigit() else 0
print(number)  # 如果输入不是数字，默认为 0
```

#### 6.2、简化逻辑

```python
# 传统写法
if condition:
    result = value1
else:
    result = value2

# 三元写法
result = value1 if condition else value2
```

#### 6.3、条件赋值

```python
# 根据条件选择字符串
message = "Success" if status_code == 200 else "Error"
```

## 三、生成器（Generator）
