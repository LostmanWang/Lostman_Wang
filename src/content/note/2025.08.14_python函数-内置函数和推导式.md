---
title: Python函数-内置函数和推导式
description: 匿名函数、生成器、内置函数和推导式
publishDate: 2025-08-14T11:26
---
## 一、匿名函数

### 1、定义

* `lambda 参数列表: 单表达式` 会即时返回一个**函数对象**，没有名字，通常作为一次性、短小逻辑的“即用即弃”函数。

### 2、基本语法

| 位置  | 写法举例                              | 说明                  |
| --- | --------------------------------- | ------------------- |
| 无参  | `lambda: 42`                      | 直接返回 42             |
| 单参  | `lambda x: x*2`                   | 输入乘以 2              |
| 多参  | `lambda x, y, z=10: x+y+z`        | 支持默认参数              |
| 可变参 | `lambda *a, **kw: len(a)+len(kw)` | 支持 \*args、\**kwargs |

#### 注意：

* **只能有一个表达式**，不能出现赋值、for、if-else 语句（三元表达式可以）。
* 返回值就是表达式的值，无需`return`。

### 3、作用域规则（与 def 完全一致）

* 遵循 LEGB；
* 同样形成闭包：

```python
# 这里 i=i 把循环变量冻结到默认参数，避免“延迟绑定陷阱”。
adders = [lambda x, i=i: x + i for i in range(3)]
print([f(10) for f in adders])   # [10, 11, 12]
```

### 4、与 `def` 的对比

| 维度  | lambda           | def        |
| --- | ---------------- | ---------- |
| 名称  | 匿名               | 必须显式命名     |
| 主体  | 单表达式             | 多语句块       |
| 结果  | 隐式 return        | 可显式 return |
| 可读性 | 极短逻辑             | 长逻辑更清晰     |
| 调试  | 栈跟踪显示 `<lambda>` | 显示函数名      |
| 注解  | 无法直接写注解          | 支持完整的函数签名  |

### 5、常见误区

#### 5.1、“lambda 比 def 快”

* 执行速度几乎一样；lambda 只是省去了栈帧名字绑定。

#### 5.2、循环变量陷阱

```python
fs = [lambda: i for i in range(3)]
print([f() for f in fs])   # [2, 2, 2]

# 解决：用默认参数或改用 def。
```

#### 5.3、试图写多行

```python
lambda x: y = x*2; return y   # SyntaxError

# 长逻辑请用 def。
```

### 6、进阶技巧

* 立即调用：`(lambda x: x**2)(5)`
* 与高阶函数搭配：`map`、`filter`、`sorted` 的`key` 参数
* 柯里化：

```python
from functools import partial
mul = lambda x, y: x * y
double = partial(mul, 2)
```

### 7、典型场景

#### 7.1、`sorted` 的 key 函数

```python
sorted(students, key=lambda s: s.score, reverse=True)
```

#### 7.2、GUI 回调 / CLI 框架

```python
button.clicked.connect(lambda: print('clicked'))
```

#### 7.3、小脚本中的过滤

```python
evens = list(filter(lambda n: n % 2 == 0, range(10)))
```

## 二、三元运算符

### 1、语法结构

```python
value_if_true if condition else value_if_false
```

* `condition`：一个布尔表达式，其结果为 True 或 False。
* `value_if_true`：如果 `condition` 为 True，则返回这个值。
* `value_if_false`：如果 `condition` 为 False，则返回这个值。

### 2、基本用法

```python
x = 10
y = 20

# 使用三元运算符
result = x if x > y else y
print(result)  # 输出 20
```

* 在这个例子中，`x > y` 是条件。因为 `x` 不大于 `y`，所以条件为 `False`，返回 `y`。

### 3、更复杂的表达式

```python
a = 5
b = 10

# 使用三元运算符嵌套
result = "Both are equal" if a == b else "a is greater" if a > b else "b is greater"
print(result)  # 输出 "b is greater"
```

### 4、与传统 `if-else` 的对比

#### 4.1、传统 `if-else`

```python
x = 10
y = 20

if x > y:
    result = x
else:
    result = y

print(result)  # 输出 20
```

#### 4.2、三元运算符

```python
x = 10
y = 20

result = x if x > y else y
print(result)  # 输出 20
```

* 三元运算符在表达简单逻辑时更加简洁，但当逻辑复杂时，建议使用传统的 `if-else` 结构，以提高代码的可读性。

### 5、注意事项

1. 可读性：虽然三元运算符很简洁，但嵌套使用时可能会降低代码的可读性。尽量避免过度嵌套。
2. 短路行为：三元运算符具有短路行为。如果条件为 True，则不会计算 `value_if_false`；如果条件为 False，则不会计算 `value_if_true`。
3. 类型一致性：虽然 Python 允许 `value_if_true` 和 `value_if_false` 是不同类型，但为了代码的可读性和一致性，建议它们是相同类型。

### 6、实际应用场景

#### 6.1、设置默认值

```python
user_input = input("Enter a number: ")
number = int(user_input) if user_input.isdigit() else 0
print(number)  # 如果输入不是数字，默认为 0
```

#### 6.2、简化逻辑

```python
# 传统写法
if condition:
    result = value1
else:
    result = value2

# 三元写法
result = value1 if condition else value2
```

#### 6.3、条件赋值

```python
# 根据条件选择字符串
message = "Success" if status_code == 200 else "Error"
```

## 三、生成器（Generator）

### 1、定义

* 生成器是一种**可迭代对象**，它**逐个生成值**，而不是一次性返回所有值。生成器函数通过 `yield` 关键字返回一个生成器对象。

### 2、生成器的核心特点

* **惰性求值**：值在需要时才生成
* **内存高效**：不需要存储整个序列在内存中
* **可恢复状态**：每次调用从上次暂停处继续执行
* **无限序列**：可以表示无限长的数据流

### 3、创建生成器的两种方式

#### 3.1、生成器函数

* 使用 `def` 定义函数，并在函数体内使用 `yield` 语句

```python
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1
```

#### 3.2、生成器表达式

* 类似列表推导式，但使用圆括号 `()`

```python
squares = (x*x for x in range(10))
```

### 4、生成器的工作流程（图示）

```textile
调用生成器函数
     │
     ▼
创建生成器对象 ────────────────┐
     │                        │
     ▼                        │
首次调用 next()               │
     │                        │
     ▼                        │
执行到第一个 yield 暂停 ◄──────┤
     │  返回 yield 的值        │
     ▼                        │
后续调用 next()               │
     │                        │
     ▼                        │
从上个 yield 后继续执行 ◄──────┘
     │
     ▼
遇到 return 或函数结束
     │
     ▼
抛出 StopIteration 异常
```

### 5、生成器函数 vs 普通函数

| 特性   | 普通函数        | 生成器函数      |
| ---- | ----------- | ---------- |
| 返回值  | 使用 `return` | 使用 `yield` |
| 执行方式 | 一次执行完成      | 可暂停和恢复     |
| 返回值  | 单次返回值       | 可多次返回值     |
| 状态   | 每次调用独立      | 保持上次执行状态   |
| 内存使用 | 可能占用大量内存    | 内存高效       |

### 6、生成器的内存模型（图示）

```textile
普通列表的内存使用：
┌──────────────┐
│ 列表对象      │
│              │
│ [0,1,4,9,16] │  存储所有元素
└──────────────┘
  ▲
  │
  └─ 占用连续内存块

生成器的内存使用：
┌──────────────┐     按需生成值
│ 生成器对象    │    ┌───┐ ┌───┐ ┌───┐
│ 状态: count=3 │───▶│ 0 │▶│ 1 │▶│ 4 │ ... 
│ 代码位置      │    └───┘ └───┘ └───┘
└──────────────┘    每次只保留
                    当前状态和代码位置
```

### 7、生成器的生命周期（代码演示）

```python
def number_generator(n):
    print("生成器启动")
    for i in range(n):
        print(f"即将生成 {i}")
        yield i
        print(f"恢复执行")
    print("生成器结束")

# 创建生成器
gen = number_generator(3)

# 逐步执行
print("第一次调用:")
print(next(gen))  # 输出: 生成器启动, 即将生成 0, 0

print("\n第二次调用:")
print(next(gen))  # 输出: 恢复执行, 即将生成 1, 1

print("\n第三次调用:")
print(next(gen))  # 输出: 恢复执行, 即将生成 2, 2

print("\n第四次调用:")
try:
    print(next(gen))  # 输出: 恢复执行, 生成器结束
except StopIteration:
    print("生成器已耗尽")
```

### 8、高级生成器特性

#### 8.1、生成器的 `send()` 方法

* 生成器不仅可以通过 `next()` 获取值，还可以通过 `send()` 方法向生成器发送值。

```python
def echo():
    while True:
        received = yield
        print(received)

e = echo()
next(e)  # 启动生成器
e.send('Hello')  # 输出 Hello
e.send('World')  # 输出 World
```

#### 8.2、生成器的 `close()` 方法

* 可以通过 `close()` 方法关闭生成器，这会触发 `GeneratorExit` 异常。

```python
def limited_counter(n):
    try:
        for i in range(n):
            yield i
    finally:
        print('Generator closed')

lc = limited_counter(3)
print(next(lc))  # 输出 0
lc.close()  # 输出 'Generator closed'
```

#### 8.3、生成器的 `throw()` 方法

* 可以通过 `throw()` 方法向生成器抛出异常。

```python
def limited_counter(n):
    try:
        for i in range(n):
            yield i
    except ValueError as e:
        print(f'Caught exception: {e}')

lc = limited_counter(3)
print(next(lc))  # 输出 0
lc.throw(ValueError('Invalid input'))  # 输出 'Caught exception: Invalid input'
```

#### 8.4、生成器表达式

```python
# 生成平方数序列
squares = (x**2 for x in range(1000000))  # 几乎不占用内存

# 等价于
def squares_gen():
    for x in range(1000000):
        yield x**2
```

#### 8.5、`yield from` 委托

```python
def chain(*iterables):
    for it in iterables:
        yield from it

list(chain('ABC', [1,2,3]))  # 输出: ['A','B','C',1,2,3]
```

### 9、生成器的内存优势（图示对比）

**处理大型数据集：**

```
普通列表方法：
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ 读取全部数据  │──▶│ 处理全部数据  │──▶│ 存储结果列表  │
└──────────────┘   └──────────────┘   └──────────────┘
      ▲                   ▲                   ▲
      └─── 高内存占用 ─────┴─── 高内存占用 ─────┘

生成器管道方法：
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ 逐项读取数据  │──▶│ 逐项处理数据  │──▶│ 逐项输出结果  │
└──────────────┘   └──────────────┘   └──────────────┘
      ▲                   ▲                   ▲
      └─── 低内存占用 ─────┴─── 低内存占用 ─────┘
```

### 10、生成器的实际应用场景

#### 10.1、处理大型文件/数据集

```python
def read_large_file(file_path):
    with open(file_path) as f:
        for line in f:
            yield line.strip()

# 使用生成器逐行处理大文件
for line in read_large_file("huge_file.txt"):
    process(line)
```

#### 10.2、无限序列

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
print(next(fib))  # 0
print(next(fib))  # 1
print(next(fib))  # 1
print(next(fib))  # 2
```

#### 10.3、数据管道

```python
def read_data(source):
    for item in source:
        yield item

def filter_data(data):
    for item in data:
        if item % 2 == 0:
            yield item

def process_data(data):
    for item in data:
        yield item * 2

# 组合生成器管道
pipeline = process_data(filter_data(read_data(range(10))))
print(list(pipeline))  # [0, 4, 8, 12, 16]
```

#### 10.4、状态机实现

```python
def state_machine():
    state = "START"
    while True:
        if state == "START":
            input = yield
            if input == "A":
                state = "STATE_A"
        elif state == "STATE_A":
            input = yield
            if input == "B":
                state = "END"
        else:
            return
```

### 11、注意事项

1. 生成器是**一次性对象**，遍历后不能重用
2. 使用 `yield` 后函数返回生成器对象，不立即执行
3. 需要手动调用 `next()` 或使用循环启动生成器
4. 生成器不存储所有值，不能随机访问

### 12、生成器与协程

* 生成器在 Python 3.5+ 中被扩展为**协程**，用于异步编程。虽然生成器和协程在底层共享很多机制，但它们的用途和语义有所不同。

```python
async def async_counter(n):
    for i in range(n):
        yield i

async for i in async_counter(3):
    print(i)  # 输出 0, 1, 2
```
