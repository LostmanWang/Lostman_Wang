---
title: python面向对象-面向对象高级和应用
description: 面向对象高级和应用
publishDate: 2025-09-10T17:36
---
## 一、三大特性--继承补充

### 1、什么是 MRO？

MRO 的全称是 Method Resolution Order，即方法解析顺序。

当你在一个对象上调用一个方法（例如 `obj.method()`) 时，Python 需要沿着继承链向上搜索，以确定应该调用哪个类中的方法。这个搜索的顺序就是 MRO。

对于简单的单继承，这非常直观：从子类到父类，一路向上。

```python
class A:
    def method(self):
        print("来自 A")

class B(A):
    pass

class C(B):
    pass

obj = C()
obj.method() # 输出：来自 A
# 搜索顺序：C -> B -> A -> object
```

**核心问题：多重继承的歧义**
当引入多重继承后，继承图不再是简单的“链”，而可能是一个复杂的“图”，甚至是一个“菱形”。这就产生了歧义：应该以何种顺序搜索父类？

```python
class A:
    def method(self):
        print("来自 A")

class B(A):
    def method(self):
        print("来自 B")

class C(A):
    def method(self):
        print("来自 C")

class D(B, C):
    pass

obj = D()
obj.method() # 应该输出什么？是 B 的还是 C 的？
```

在这个经典的“菱形继承”问题中，搜索顺序可以是：

1. `D -> B -> A -> C -> A`（深度优先，但重复访问 A 是糟糕的）
2. `D -> B -> C -> A`（广度优先）
3. 或者其他顺序...

Python 必须有一个一致、可靠且可预测的规则来决定这个顺序。这就是 MRO 算法要解决的问题。

### 2、C3 算法详解

C3 算法的核心是为一个类生成一个线性化（MRO 列表），这个线性化需要满足以下两个关键约束：

1. **一致性保持局部优先顺序**：

   如果一个类在继承列表中出现在另一个类之前（如 `class D(B, C)` 中 `B` 在 `C` 之前），那么在 MRO 中，`B` 也应该出现在 `C` 之前。

   子类在父类之前
2. **单调性**：如果一个类 `A` 在另一个类 `B` 之前被解析，那么在所有子类中，这个顺序都必须保持。换句话说，**在继承图中，子类的 MRO 应该包含父类的 MRO，并且父类的 MRO 顺序在子类中保持不变**。这是保证继承可靠性的基石。

#### C3 算法的步骤与公式

C3 算法的操作可以描述为一个递归的合并过程。对于一个类 `C`，其继承列表为 `[B1, B2, ..., BN]`，`C` 的 MRO 计算如下：

`L[C] = [C] + merge(L[B1], L[B2], ..., L[BN], [B1, B2, ..., BN])`

这里的 `L[Cls]` 代表类 `Cls` 的 MRO 列表，`merge` 是一个特殊的合并函数。

#### `merge` 操作规则

`merge` 函数接收多个列表（线性化）作为参数，并按以下规则合并它们：

  检查第一个列表的**第一个元素**。

  如果这个元素**没有**出现在任何其他列表的**非首位**，那么它就是一个“好头”，可以将其从所有列表中移除，并添加到输出结果中。

  如果这个元素出现在其他列表的非首位，则跳过它，去检查下一个列表的第一个元素。

  重复这个过程，直到所有列表都被耗尽。

如果找不到符合规则的“好头”，则算法无法构建一个一致的线性化，Python 会抛出 `TypeError`（这意味着类的继承 hierarchy 本身就有问题）。

## 二、内置函数补充
