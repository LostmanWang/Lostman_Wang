---
title: python面向对象-面向对象进阶
description: 面向对象进阶
publishDate: 2025-09-11T16:04
---
### 2.3、类方法（Class Method）

##### 6、实战示例：

1.工厂方法（备用构造器）

```python
class Person:
    species = "Homo sapiens"

    def __init__(self, name):
        self.name = name

    @classmethod
    def set_species(cls, new_species):
        cls.species = new_species          # 修改类变量
        return cls                         # 便于链式调用

    @classmethod
    def from_dict(cls, data):
        return cls(data["name"])           # 工厂方法

# 使用
Person.set_species("Modern human")         # 类名调用
p = Person.from_dict({"name": "Alice"})    # 工厂方法
print(Person.species, p.name)              # Modern human Alice
```

方法内部用 `cls(data["name"])` 调用了真正的构造函数 `__init__`，并返回新建好的实例。

调用者无需直接写 `Person(...)`，只要传字典即可：`p = Person.from_dict({"name": "Alice"})`等价于`p = Person("Alice")`

2. 子类继承时自动拿到正确子类

```python
class Base:
    label = "base"

    @classmethod
    def create(cls):
        print(f"Creating {cls.label}")
        return cls()

class Derived(Base):
    label = "derived"

Base.create()     # Creating base
Derived.create()  # Creating derived
```

注意：如果用 `Base()` 硬编码，子类就得不到正确类型。

```python
class Base:
    label = "base"
    @classmethod
    def create(cls):
        print(f"Creating {cls.label}")
        return Base()         # ← 写死成 Base

class Derived(Base):
    label = "derived"

>>> Derived.create()     # 虽然 cls 是 Derived，但永远 new Base()
Creating derived          # 打印的是子类标签，可对象却是 Base
<__main__.Base object at 0x...>
```
