---
title: python面向对象-面向对象进阶
description: 面向对象进阶
publishDate: 2025-09-11T16:04
---
### 2.3、类方法（Class Method）

##### 常见用途

| 场景                  | 示例                         |
| ------------------- | -------------------------- |
| **备选构造器**（工厂方法）     | `datetime.fromtimestamp()` |
| **统计/配置** 等需要类级共享数据 | 记录实例个数、全局默认配置              |
| **在子类中自动拿到正确子类**    | 避免硬编码类名                    |

##### 实战示例

1.工厂方法（备用构造器）

```python
class Person:
    species = "Homo sapiens"

    def __init__(self, name):
        self.name = name

    @classmethod
    def set_species(cls, new_species):
        cls.species = new_species          # 修改类变量
        return cls                         # 便于链式调用

    @classmethod
    def from_dict(cls, data):
        return cls(data["name"])           # 工厂方法

# 使用
Person.set_species("Modern human")         # 类名调用
p = Person.from_dict({"name": "Alice"})    # 工厂方法
print(Person.species, p.name)              # Modern human Alice
```

方法内部用 `cls(data["name"])` 调用了真正的构造函数 `__init__`，并返回新建好的实例。

调用者无需直接写 `Person(...)`，只要传字典即可：`p = Person.from_dict({"name": "Alice"})`等价于`p = Person("Alice")`

2. 子类继承时自动拿到正确子类

```python
class Base:
    label = "base"

    @classmethod
    def create(cls):
        print(f"Creating {cls.label}")
        return cls()

class Derived(Base):
    label = "derived"

Base.create()     # Creating base
Derived.create()  # Creating derived
```

注意：如果用 `Base()` 硬编码，子类就得不到正确类型。

```python
class Base:
    label = "base"
    @classmethod
    def create(cls):
        print(f"Creating {cls.label}")
        return Base()         # ← 写死成 Base

class Derived(Base):
    label = "derived"

>>> Derived.create()     # 虽然 cls 是 Derived，但永远 new Base()
Creating derived          # 打印的是子类标签，可对象却是 Base
<__main__.Base object at 0x...>
```

在类方法里 **永远不要硬编码类名去实例化**，应当用 `cls(...)`，保证“谁调用，就生成谁类型的对象”。

##### 容易被忽略的细节

| 要点                      | 说明                                                                               |
| ----------------------- | -------------------------------------------------------------------------------- |
| **描述器协议**               | `classmethod` 对象实现了 `__get__`，因此只能 **挂在类属性上**；如果你把它赋值给实例属性，再访问时不会触发描述器，得到的只是裸函数。 |
| **不能跟 staticmethod 混用** | `@classmethod` 必须紧贴函数，顺序错会失效：<br>`@classmethod` `@staticmethod` → 报错或行为异常。       |
| **绑定行为**                | 类方法一旦通过 **子类** 访问，`cls` 就是 **子类本身**，这让它在框架代码里特别有用。                               |
| **与元类配合**               | 在元类里用 `classmethod` 可以给 **元类自身** 定义类方法（此时 `cls` 是元类）。                            |

### 2.4、静态方法（@staticmethod）
