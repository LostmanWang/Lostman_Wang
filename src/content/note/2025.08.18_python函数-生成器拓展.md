---
title: Python函数-生成器拓展
description: yield 生成器
publishDate: 2025-08-18T19:51
---
## 一、高级生成器特性

### 1、生成器的 `send()` 方法

* 生成器不仅可以通过 `next()` 获取值，还可以通过 `send()` 方法向生成器发送值。

```python
def echo():
    while True:
        received = yield
        print(received)

e = echo()
next(e)  # 启动生成器
e.send('Hello')  # 输出 Hello
e.send('World')  # 输出 World
```

### 2、生成器的 `close()` 方法

* 可以通过 `close()` 方法关闭生成器，这会触发 `GeneratorExit` 异常。

```python
def limited_counter(n):
    try:
        for i in range(n):
            yield i
    finally:
        print('Generator closed')

lc = limited_counter(3)
print(next(lc))  # 输出 0
lc.close()  # 输出 'Generator closed'
```

### 3、生成器的 `throw()` 方法

* 可以通过 `throw()` 方法向生成器抛出异常。

```python
def limited_counter(n):
    try:
        for i in range(n):
            yield i
    except ValueError as e:
        print(f'Caught exception: {e}')

lc = limited_counter(3)
print(next(lc))  # 输出 0
lc.throw(ValueError('Invalid input'))  # 输出 'Caught exception: Invalid input'
```

### 4、生成器表达式

```python
# 生成平方数序列
squares = (x**2 for x in range(1000000))  # 几乎不占用内存

# 等价于
def squares_gen():
    for x in range(1000000):
        yield x**2
```

### 5、`yield from` 委托

#### 5.1、基本语法

```python
def generator():
    yield from iterable
    
# iterable 可以是任何可迭代对象，包括生成器、列表、元组等。
```

#### 5.2、工作原理

当执行到 `yield from iterable` 时，Python 会：

1. 遍历`iterable` 中的每个元素。
2. 将每个元素依次 `yield` 出去。
3. 如果 `iterable` 是一个生成器，那么 `yield from` 会捕获生成器的 `StopIteration` 异常（该异常在生成器耗尽时抛出），并正常结束外层生成器。

#### 5.3、示例

```python
# 从列表中 yield 值

def generator():
    yield from [1, 2, 3, 4, 5]

for value in generator():
    print(value, end=" ") # 1 2 3 4 5
```

```python
# 从另一个生成器中 yield 值

def inner_generator():
    yield from range(3)
    yield from [10, 20, 30]

def outer_generator():
    yield from inner_generator()

for value in outer_generator():
    print(value, end=" ") # 0 1 2 10 20 30
```

##### **高级用法**

```python
# 使用 yield from 简化递归生成器

def recursive_generator(n):
    if n > 0:
        yield from recursive_generator(n-1)
    yield n

for value in recursive_generator(3):
    print(value, end=" ") # 0 1 2 3
```

```textile
初始化生成器：
  调用 recursive_generator(3) 创建生成器对象。
  此时，n 的值为 3。

递归调用：
  检查 n > 0 条件，因为 n 为 3，条件为真。
  执行 yield from recursive_generator(n-1)，即 yield from recursive_generator(2)。
  这会导致生成器函数再次被调用，但这次 n 的值为 2。

…

递归基案：
  检查 n > 0 条件，因为 n 为 0，条件为假。
  执行 yield n，即 yield 0，生成器开始返回值。
  recursive_generator(0) 完成，0 被 yield 出去。

递归回溯：
  recursive_generator(1) 接收到 0，继续执行 yield n，即 yield 1。
  recursive_generator(2) 接收到 1，继续执行 yield n，即 yield 2。
  recursive_generator(3) 接收到 2，继续执行 yield n，即 yield 3。

输出结果：
  外层循环 for value in recursive_generator(3) 依次接收到 0、1、2、3，并打印这些值。
```

```python
# 处理生成器中的错误

def inner_gen():
    try:
        yield 1
        yield 2
        raise Exception('Something went wrong')
    except Exception as e:
        yield 'Error handled'

def outer_gen():
    yield from inner_gen()

for value in outer_gen():
    print(value, end=" ") # 1 2 Error handled
```

##### **与 `yield` 的区别**

* `yield`：用于从生成器中返回一个值，并在下一次调用 `next()` 时从上次停止的地方继续执行。
* `yield from`：用于将一个生成器或可迭代对象的输出转发到另一个生成器。它允许生成器委托给另一个生成器，从而简化代码。

### 9、生成器的内存优势（图示对比）

**处理大型数据集：**

```
普通列表方法：
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ 读取全部数据  │──▶│ 处理全部数据  │──▶│ 存储结果列表  │
└──────────────┘   └──────────────┘   └──────────────┘
      ▲                   ▲                   ▲
      └─── 高内存占用 ─────┴─── 高内存占用 ─────┘

生成器管道方法：
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ 逐项读取数据  │──▶│ 逐项处理数据  │──▶│ 逐项输出结果  │
└──────────────┘   └──────────────┘   └──────────────┘
      ▲                   ▲                   ▲
      └─── 低内存占用 ─────┴─── 低内存占用 ─────┘
```

### 10、生成器的实际应用场景

#### 10.1、处理大型文件/数据集

```python
def read_large_file(file_path):
    with open(file_path) as f:
        for line in f:
            yield line.strip()

# 使用生成器逐行处理大文件
for line in read_large_file("huge_file.txt"):
    process(line)
```

#### 10.2、无限序列

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
print(next(fib))  # 0
print(next(fib))  # 1
print(next(fib))  # 1
print(next(fib))  # 2
```

#### 10.3、数据管道

```python
def read_data(source):
    for item in source:
        yield item

def filter_data(data):
    for item in data:
        if item % 2 == 0:
            yield item

def process_data(data):
    for item in data:
        yield item * 2

# 组合生成器管道
pipeline = process_data(filter_data(read_data(range(10))))
print(list(pipeline))  # [0, 4, 8, 12, 16]
```

#### 10.4、状态机实现

```python
def state_machine():
    state = "START"
    while True:
        if state == "START":
            input = yield
            if input == "A":
                state = "STATE_A"
        elif state == "STATE_A":
            input = yield
            if input == "B":
                state = "END"
        else:
            return
```

### 11、注意事项

1. 生成器是**一次性对象**，遍历后不能重用
2. 使用 `yield` 后函数返回生成器对象，不立即执行
3. 需要手动调用 `next()` 或使用循环启动生成器
4. 生成器不存储所有值，不能随机访问

### 12、生成器与协程

* 生成器在 Python 3.5+ 中被扩展为**协程**，用于异步编程。虽然生成器和协程在底层共享很多机制，但它们的用途和语义有所不同。

```python
async def async_counter(n):
    for i in range(n):
        yield i

async for i in async_counter(3):
    print(i)  # 输出 0, 1, 2
```

### 拓展：

#### 12.1、概念

* `send(value)` 把 **外部数据** 通过 `yield` 表达式 **注入** 到生成器内部，并立即恢复生成器执行，直至下一个 `yield` 或 `StopIteration`。

#### 12.2、基本语法

```python
def coro():
    received = yield 1          # ① 先产出 1；② 外部 send 的值赋给 received
    print("收到：", received)
    yield 2

gen = coro()
first = next(gen)               # 必须首次激活，进入 ①
second = gen.send("Hello")      # 把 "Hello" 注入 received，继续到 ②
```

#### 12.3、运行步骤逐帧跟踪

| 行号  | 生成器代码                | 外部调用                | 生成器状态            | 返回值  |
| --- | -------------------- | ------------------- | ---------------- | ---- |
| 1   | `received = yield 1` | `next(gen)`         | 停在 yield 1       | 1    |
| 2   | `print(received)`    | `gen.send("Hello")` | 继续执行             | None |
| 3   | `yield 2`            | 同上                  | 停在 yield 2       | 2    |
| 4   | 函数结束                 | 同上                  | 抛出 StopIteration | \-   |

#### 12.4、`send()` 与 `next()` 的区别

| 方法               | 是否注入值 | 首次启动 | 典型用途     |
| ---------------- | ----- | ---- | -------- |
| `next(gen)`      | 否     | ✅    | 仅仅推进     |
| `gen.send(None)` | 否     | ✅    | 同 `next` |
| `gen.send(v)`    | 是     | ❌    | 双向通信     |

#### 12.5、异步场景——“协程雏形”

在 `async/await` 出现前，生成器 + `send()` 就是 **协程** 的底层实现：

* `yield` 暂停 I/O；
* 事件循环用 `send(result)` 把 I/O 结果送回生成器，从而“异步”继续执行 。

#### 12.6、完整示例：计数协程 + 外部注入

```python
def counter():
    count = 0
    while True:
        step = yield count      # 产出当前值，等待外部 step
        if step is None:        # 首次 next 时 step 为 None
            step = 1
        count += step

c = counter()
print(next(c), end=',')          # 0
print(c.send(5), end=',')        # 5  (0 + 5)
print(c.send(-2))       # 3  (5 - 2)

输出：0,5,3
```

#### 12.7、常见陷阱

##### **首次忘记 `next()`**

* 直接`gen.send(123)`会抛 `TypeError`，因为生成器尚未启动。

##### **在 `yield` 前 `return`**

* `send()` 之后若立即`return`，将抛出 `StopIteration(value)`，`value` 即 `return` 的值。

##### **循环变量闭包**

* 在列表推导式里使用 `send()` 时要注意延迟绑定问题，与 lambda 闭包类似。
